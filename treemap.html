<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cargo Bloat Treemap</title>
<style>
  :root {
    --bg: #000;
    --surface: #000;
    --text: #e0e0e0;
    --text-muted: #8888aa;
    --accent: #0f3460;
    --border: #2a2a4a;
    --tooltip-bg: #0d1117;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', monospace;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    user-select: none;
  }

  header {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 10px 16px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    flex-wrap: wrap;
  }

  header h1 { font-size: 15px; font-weight: 600; white-space: nowrap; }

  .controls {
    display: flex;
    align-items: center;
    gap: 12px;
    flex-wrap: wrap;
  }

  .file-input-wrapper { position: relative; }

  .file-input-wrapper input[type="file"] {
    position: absolute; top: 0; left: 0; opacity: 0; width: 100%; height: 100%; cursor: pointer;
  }

  .btn {
    padding: 5px 14px;
    border-radius: 4px;
    border: 1px solid var(--border);
    background: var(--accent);
    color: var(--text);
    font-family: inherit;
    font-size: 12px;
    cursor: pointer;
    white-space: nowrap;
  }

  .btn:hover { background: #1a4a80; }

  .threshold-control {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: var(--text-muted);
  }

  .threshold-control input[type="range"] { width: 80px; accent-color: #537ec5; }

  .breadcrumbs {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 12px;
    flex-wrap: wrap;
  }

  .breadcrumb {
    padding: 2px 8px;
    border-radius: 3px;
    cursor: pointer;
    color: #537ec5;
    background: none;
    border: none;
    font-family: inherit;
    font-size: 12px;
  }

  .breadcrumb:hover { background: rgba(83, 126, 197, 0.15); }
  .breadcrumb-sep { color: var(--text-muted); }

  .info-bar {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 6px 16px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    font-size: 11px;
    color: var(--text-muted);
    flex-shrink: 0;
  }

  #drop-zone {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }

  #drop-zone.empty { cursor: pointer; }

  .drop-prompt { text-align: center; color: var(--text-muted); }
  .drop-prompt h2 { font-size: 18px; margin-bottom: 8px; font-weight: 500; }
  .drop-prompt p { font-size: 13px; }

  #treemap-container {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .tm-node {
    position: absolute;
    overflow: hidden;
    background: #000;
  }

  .tm-node-inner {
    position: absolute;
    inset: 0;
    overflow: hidden;
  }

  .tm-label {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding: 2px 5px;
    font-size: 11px;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    pointer-events: none;
    z-index: 1;
    line-height: 18px;
  }

  .tm-label-size {
    font-weight: 400;
    opacity: 0.7;
    font-size: 10px;
  }

  .tm-leaf:hover {
    outline: 2px solid rgba(255, 255, 255, 0.7);
    outline-offset: -2px;
    z-index: 100;
  }

  .tm-branch:hover > .tm-node-inner {
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.2);
  }

  .tm-leaf, .tm-branch { cursor: pointer; }

  .tm-remainder > .tm-node-inner {
    background-image: repeating-linear-gradient(
      45deg, transparent, transparent 4px,
      rgba(255,255,255,0.04) 4px, rgba(255,255,255,0.04) 8px
    ) !important;
  }

  #tooltip {
    position: fixed;
    display: none;
    background: var(--tooltip-bg);
    border: 1px solid #444;
    border-radius: 6px;
    padding: 10px 14px;
    font-size: 12px;
    line-height: 1.7;
    max-width: 550px;
    z-index: 10000;
    pointer-events: none;
    box-shadow: 0 4px 24px rgba(0,0,0,0.6);
  }

  .tt-path { color: #7ec8e3; font-weight: 600; word-break: break-all; margin-bottom: 6px; }
  .tt-row { display: flex; justify-content: space-between; gap: 24px; }
  .tt-label { color: var(--text-muted); }
  .tt-value { color: var(--text); font-weight: 500; }
  .tt-hint { color: #666; font-size: 10px; margin-top: 6px; font-style: italic; }

  .modal-overlay {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6);
    display: flex; align-items: center; justify-content: center; z-index: 9999;
  }

  .modal {
    background: var(--surface); border: 1px solid var(--border); border-radius: 8px;
    padding: 20px; width: 600px; max-width: 90vw; max-height: 80vh;
    display: flex; flex-direction: column; gap: 12px;
  }

  .modal h3 { font-size: 14px; }

  .modal textarea {
    width: 100%; height: 300px; background: var(--bg); color: var(--text);
    border: 1px solid var(--border); border-radius: 4px; padding: 10px;
    font-family: inherit; font-size: 12px; resize: vertical;
  }

  .modal-actions { display: flex; justify-content: flex-end; gap: 8px; }
</style>
</head>
<body>

<header>
  <h1>Cargo Bloat Treemap</h1>
  <div class="controls">
    <div class="file-input-wrapper">
      <button class="btn">Load JSON</button>
      <input type="file" id="file-input" accept=".json">
    </div>
    <button class="btn" id="paste-btn">Paste JSON</button>
    <div class="threshold-control">
      <label for="threshold">Remainder grouping:</label>
      <input type="range" id="threshold" min="0.5" max="8" step="0.5" value="2">
      <span id="threshold-val">2%</span>
    </div>
  </div>
  <div class="breadcrumbs" id="breadcrumbs"></div>
</header>

<div class="info-bar" id="info-bar" style="display:none">
  <span id="info-file-size"></span>
  <span id="info-text-size"></span>
  <span id="info-functions"></span>
  <span id="info-crates"></span>
  <div class="breadcrumbs" id="breadcrumbs-bar"></div>
</div>

<div id="drop-zone" class="empty">
  <div class="drop-prompt" id="drop-prompt">
    <h2>Drop cargo-bloat JSON here</h2>
    <p>or use the buttons above to load / paste data</p>
    <p style="margin-top:12px; font-size:11px; color:#555">
      Generate with: cargo bloat --release --message-format=json &gt; bloat.json
    </p>
  </div>
  <div id="treemap-container" style="display:none"></div>
</div>

<div id="tooltip">
  <div class="tt-path" id="tt-path"></div>
  <div class="tt-row"><span class="tt-label">Size</span><span class="tt-value" id="tt-size"></span></div>
  <div class="tt-row"><span class="tt-label">% of text section</span><span class="tt-value" id="tt-pct-total"></span></div>
  <div class="tt-row"><span class="tt-label">% of parent</span><span class="tt-value" id="tt-pct-parent"></span></div>
  <div class="tt-row" id="tt-children-row" style="display:none"><span class="tt-label">Children</span><span class="tt-value" id="tt-children"></span></div>
  <div class="tt-hint" id="tt-hint"></div>
</div>

<script>
// ─── Global state ───────────────────────────────────────────────────────────

let rawData = null;
let treeRoot = null;
let thresholdPct = 2;
let totalTextSize = 0;

// Node identity: every original tree node gets a unique ID so zoom can
// reference the *original* tree even though we render clones.
let nextNodeId = 0;
const nodeById = new Map();

// Zoom stack stores original-node IDs + the crate color in effect
let zoomStack = []; // { nodeId, crateColor }

// Stable crate -> color mapping (assigned once during tree build)
const crateColorMap = new Map();
let crateColorIdx = 0;

// ─── Color helpers ──────────────────────────────────────────────────────────

// Generate maximally-spaced hues using golden angle so neighbors contrast well
const CRATE_HUES = (() => {
  const colors = [];
  const golden = 137.508;
  for (let i = 0; i < 30; i++) {
    const h = (i * golden) % 360;
    // HSL to RGB with S=80%, L=60% — bright base colors, opacity stacking creates depth
    const s = 0.80, l = 0.60;
    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs((h / 60) % 2 - 1));
    const m = l - c / 2;
    let r, g, b;
    if (h < 60)       { r = c; g = x; b = 0; }
    else if (h < 120) { r = x; g = c; b = 0; }
    else if (h < 180) { r = 0; g = c; b = x; }
    else if (h < 240) { r = 0; g = x; b = c; }
    else if (h < 300) { r = x; g = 0; b = c; }
    else              { r = c; g = 0; b = x; }
    colors.push([
      Math.round((r + m) * 255),
      Math.round((g + m) * 255),
      Math.round((b + m) * 255),
    ]);
  }
  return colors;
})();

function assignCrateColor(name) {
  if (crateColorMap.has(name)) return crateColorMap.get(name);
  const rgb = CRATE_HUES[crateColorIdx % CRATE_HUES.length];
  crateColorIdx++;
  crateColorMap.set(name, rgb);
  return rgb;
}

function rgbStr([r, g, b]) { return `rgb(${r},${g},${b})`; }

function adjustRgb([r, g, b], amt) {
  return [
    Math.max(0, Math.min(255, r + amt)),
    Math.max(0, Math.min(255, g + amt)),
    Math.max(0, Math.min(255, b + amt)),
  ];
}

function rgbaStr([r, g, b], a) { return `rgba(${r},${g},${b},${a})`; }

// ─── Rust path parsing ──────────────────────────────────────────────────────

function splitRustPath(path) {
  const segments = [];
  let cur = '';
  let depth = 0;
  for (let i = 0; i < path.length; i++) {
    const ch = path[i];
    if (ch === '<') depth++;
    else if (ch === '>') depth--;
    if (ch === ':' && i + 1 < path.length && path[i + 1] === ':' && depth === 0) {
      if (cur) segments.push(cur);
      cur = '';
      i++;
      continue;
    }
    cur += ch;
  }
  if (cur) segments.push(cur);
  return segments;
}

function parseFunctionPath(name, crateName) {
  const crate = (crateName || '[unknown]').replace(/\?$/, '');

  if (name.startsWith('<')) {
    // Trait impl: <Type as Trait>::method
    const asIdx = name.indexOf(' as ');
    if (asIdx !== -1) {
      const selfType = name.substring(1, asIdx);
      const rest = name.substring(asIdx);
      const closeIdx = rest.indexOf('>::');
      if (closeIdx !== -1) {
        const traitFull = rest.substring(4, closeIdx);
        const method = rest.substring(closeIdx + 3);
        const traitShort = splitRustPath(traitFull).pop();
        const selfSegs = splitRustPath(selfType);
        const path = selfSegs[0] === crate ? selfSegs.slice(1) : selfSegs;
        return { crate, path, leaf: `<impl ${traitShort}>::${method}`, fullName: name };
      }
    }
    // Inherent impl: <Type>::method
    const closeIdx = name.indexOf('>::');
    if (closeIdx !== -1) {
      const typePart = name.substring(1, closeIdx);
      const method = name.substring(closeIdx + 3);
      const segs = splitRustPath(typePart);
      const path = segs[0] === crate ? segs.slice(1) : segs;
      return { crate, path, leaf: method, fullName: name };
    }
  }

  // Regular: crate::mod::submod::fn
  const segs = splitRustPath(name);
  const leaf = segs.pop() || name;
  const path = segs[0] === crate ? segs.slice(1) : segs;
  return { crate, path, leaf, fullName: name };
}

// ─── Tree building ──────────────────────────────────────────────────────────

function makeNode(name, fullPath) {
  const id = nextNodeId++;
  const node = { _id: id, name, children: {}, size: 0, fullPath, isLeaf: false, isRemainder: false };
  nodeById.set(id, node);
  return node;
}

let leafCounter = 0;

function buildTree(data) {
  nextNodeId = 0;
  nodeById.clear();
  crateColorMap.clear();
  crateColorIdx = 0;
  leafCounter = 0;

  const root = makeNode('root', 'root');
  root.isRoot = true;

  for (const fn of data.functions) {
    if (!fn.name || !fn.size) continue;
    const parsed = parseFunctionPath(fn.name, fn.crate);
    const crateName = parsed.crate;

    // Assign stable color for this crate
    assignCrateColor(crateName);

    // Get or create crate node
    if (!root.children[crateName]) {
      root.children[crateName] = makeNode(crateName, crateName);
    }

    let node = root.children[crateName];
    node.size += fn.size;
    root.size += fn.size;

    // Navigate/create module path
    let curPath = crateName;
    for (const seg of parsed.path) {
      curPath += '::' + seg;
      if (!node.children[seg]) {
        node.children[seg] = makeNode(seg, curPath);
      }
      node = node.children[seg];
      node.size += fn.size;
    }

    // Add leaf (use global counter to guarantee uniqueness)
    const leafKey = '__leaf_' + (leafCounter++);
    const leaf = makeNode(parsed.leaf, parsed.fullName);
    leaf.size = fn.size;
    leaf.isLeaf = true;
    node.children[leafKey] = leaf;
  }

  return root;
}

// ─── Remainder grouping (operates on cloned trees) ──────────────────────────

function applyRemainders(node, threshPct) {
  const childArr = Object.values(node.children);
  if (childArr.length === 0) return;

  const threshold = node.size * (threshPct / 100);

  // Sort children descending by size so we keep the big ones and group the tail
  const sorted = childArr.slice().sort((a, b) => b.size - a.size);
  const keep = [];
  const small = [];

  for (const child of sorted) {
    if (child.size < threshold) {
      small.push(child);
    } else {
      keep.push(child);
    }
  }

  // Only create a remainder if:
  // 1. There are items to keep (not everything is small)
  // 2. The remainder total is small relative to the parent (< 15%)
  // 3. There are at least 2 small items (no point grouping 1)
  const remainderSize = small.reduce((s, c) => s + c.size, 0);
  const remainderTooBig = remainderSize > node.size * 0.15;

  if (keep.length === 0 || remainderTooBig || small.length < 2) {
    // Keep everything, just recurse
    for (const child of childArr) {
      if (!child.isLeaf) applyRemainders(child, threshPct);
    }
    return;
  }

  // Recurse into kept children
  for (const child of keep) {
    if (!child.isLeaf) applyRemainders(child, threshPct);
  }

  // Rebuild children
  node.children = {};
  for (const k of keep) {
    node.children['_k_' + k._id] = k;
  }

  if (small.length > 0) {
    const rem = {
      _id: -1,
      _originalId: -1,
      name: `[${small.length} smaller items]`,
      children: {},
      size: remainderSize,
      fullPath: node.fullPath + '::[other]',
      isLeaf: true,
      isRemainder: true,
      remainderCount: small.length,
    };
    node.children['__remainder__'] = rem;
  }
}

function deepCloneTree(node) {
  const clone = { ...node, _originalId: node._id, children: {} };
  for (const [k, v] of Object.entries(node.children)) {
    clone.children[k] = deepCloneTree(v);
  }
  return clone;
}

// ─── Squarify treemap layout ────────────────────────────────────────────────

function squarify(items, x, y, w, h) {
  if (items.length === 0) return [];
  const total = items.reduce((s, i) => s + i.size, 0);
  if (total <= 0 || w <= 0 || h <= 0) return [];

  const sorted = items.slice().sort((a, b) => b.size - a.size);
  const result = [];
  layoutRows(sorted, x, y, w, h, total, result);
  return result;
}

function layoutRows(items, x, y, w, h, total, result) {
  if (items.length === 0) return;
  if (items.length === 1) {
    result.push({ ...items[0], x, y, w, h });
    return;
  }

  const vertical = h > w; // lay strips along the shorter axis
  const mainLen = vertical ? h : w;
  const crossLen = vertical ? w : h;

  // Find best row using squarify heuristic
  let rowItems = [];
  let rowSize = 0;
  let bestWorst = Infinity;
  let bestN = 1;

  for (let i = 0; i < items.length; i++) {
    rowItems.push(items[i]);
    rowSize += items[i].size;

    const rowFrac = rowSize / total;
    const rowDim = rowFrac * mainLen;

    let worst = 0;
    for (const ri of rowItems) {
      const itemCross = (ri.size / rowSize) * crossLen;
      if (rowDim > 0 && itemCross > 0) {
        worst = Math.max(worst, Math.max(rowDim / itemCross, itemCross / rowDim));
      } else {
        worst = Infinity;
      }
    }

    if (worst <= bestWorst) {
      bestWorst = worst;
      bestN = i + 1;
    } else {
      break;
    }
  }

  const row = items.slice(0, bestN);
  const rest = items.slice(bestN);
  const rSize = row.reduce((s, i) => s + i.size, 0);
  const rowFrac = rSize / total;
  const rowDim = rowFrac * mainLen;

  let offset = 0;
  for (const item of row) {
    const itemCross = (item.size / rSize) * crossLen;
    if (vertical) {
      result.push({ ...item, x: x + offset, y, w: itemCross, h: rowDim });
    } else {
      result.push({ ...item, x, y: y + offset, w: rowDim, h: itemCross });
    }
    offset += itemCross;
  }

  if (rest.length > 0) {
    const restTotal = total - rSize;
    if (vertical) {
      layoutRows(rest, x, y + rowDim, w, h - rowDim, restTotal, result);
    } else {
      layoutRows(rest, x + rowDim, y, w - rowDim, h, restTotal, result);
    }
  }
}

// ─── Rendering ──────────────────────────────────────────────────────────────

const HEADER_H = 20;
const PAD = 0;
const MIN_LABEL_W = 35;
const MIN_LABEL_H = 16;
const MIN_CHILD_AREA = 600; // px^2 - minimum area to recurse into children

function renderTreemap(rootNode, container, initialCrateRgb) {
  container.innerHTML = '';
  const rect = container.getBoundingClientRect();
  renderNode(rootNode, container, 0, 0, rect.width, rect.height, 0, initialCrateRgb || null, rootNode.size);
}

function renderNode(node, container, x, y, w, h, depth, crateRgb, parentSize) {
  if (w < 2 || h < 2) return;

  const children = Object.values(node.children);
  const hasChildren = children.length > 0 && !node.isLeaf;
  const isLeaf = !hasChildren;

  // Resolve crate color: at depth 1 (crate level in root view), or from
  // the inherited crateRgb when zoomed into a subtree. Also check if the
  // current node itself is a known crate (handles zoomed-in views).
  if (!crateRgb) {
    const lookup = crateColorMap.get(node.name);
    if (lookup) crateRgb = lookup;
  }
  if (depth === 1 && !crateRgb) {
    crateRgb = [80, 80, 100]; // fallback
  }
  const baseRgb = crateRgb || [80, 80, 100];

  const el = document.createElement('div');
  el.className = 'tm-node' + (isLeaf ? ' tm-leaf' : ' tm-branch') + (node.isRemainder ? ' tm-remainder' : '');
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  el.style.width = w + 'px';
  el.style.height = h + 'px';

  const inner = document.createElement('div');
  inner.className = 'tm-node-inner';

  // Black border via gap: outer .tm-node is black, inner is inset to reveal the black frame
  const bw = Math.max(1, 3 - depth); // px of black border
  inner.style.inset = bw + 'px';

  // Each layer adds opacity — stacking makes deeper boxes brighter and more saturated
  if (depth === 0) {
    inner.style.background = 'transparent';
    inner.style.inset = '0';
    el.style.background = 'transparent';
  } else if (node.isRemainder) {
    inner.style.background = 'rgba(128,128,128,0.35)';
  } else {
    inner.style.background = rgbaStr(baseRgb, 0.35);
  }

  // Label
  const canLabel = w > MIN_LABEL_W && h > MIN_LABEL_H;
  let headerH = 0;

  if (canLabel && !isLeaf && depth > 0) {
    const label = document.createElement('div');
    label.className = 'tm-label';
    const sizeStr = formatSize(node.size);
    label.innerHTML = `<span>${esc(node.name)}</span> <span class="tm-label-size">${sizeStr}</span>`;
    label.style.color = node.isRemainder ? '#999' : '#ddd';
    label.style.background = node.isRemainder ? 'rgba(128,128,128,0.35)' : rgbaStr(baseRgb, 0.35);
    label.style.borderBottom = '2px solid #000';
    label.style.zIndex = '2';
    el.appendChild(label);
    headerH = HEADER_H;
  } else if (canLabel && isLeaf) {
    const label = document.createElement('div');
    label.className = 'tm-label';
    label.textContent = node.name;
    label.style.color = node.isRemainder ? '#888' : '#ccc';
    label.style.fontSize = w < 70 ? '9px' : '11px';
    inner.appendChild(label);
  }

  // Store data for tooltip + zoom
  el._tmNode = node;
  el._tmParentSize = parentSize;
  el._tmCrateRgb = crateRgb;

  // Tooltip
  el.addEventListener('mouseenter', onNodeEnter);
  el.addEventListener('mousemove', onTooltipMove);
  el.addEventListener('mouseleave', onNodeLeave);

  // Click to zoom into branch nodes
  if (!isLeaf && depth > 0) {
    el.addEventListener('click', onNodeClick);
  }

  el.appendChild(inner);
  container.appendChild(el);

  // Render children into the OUTER el so their borders overlap with parent borders
  if (hasChildren) {
    const iy = bw + headerH;
    const iw = w;
    const ih = h - iy;

    if (iw * ih >= MIN_CHILD_AREA && iw > 10 && ih > 10) {
      const childItems = children.map(c => ({ size: c.size, node: c }));
      const laid = squarify(childItems, 0, 0, iw, ih);

      for (const item of laid) {
        renderNode(
          item.node, el,
          item.x, iy + item.y,
          item.w, item.h,
          depth + 1, crateRgb, node.size
        );
      }
    }
  }
}

// ─── Tooltip ────────────────────────────────────────────────────────────────

const tooltip = document.getElementById('tooltip');
const ttPath = document.getElementById('tt-path');
const ttSize = document.getElementById('tt-size');
const ttPctTotal = document.getElementById('tt-pct-total');
const ttPctParent = document.getElementById('tt-pct-parent');
const ttChildrenRow = document.getElementById('tt-children-row');
const ttChildren = document.getElementById('tt-children');
const ttHint = document.getElementById('tt-hint');

function onNodeEnter(e) {
  e.stopPropagation();
  const el = e.currentTarget;
  const node = el._tmNode;
  const parentSize = el._tmParentSize;

  ttPath.textContent = node.fullPath || node.name;
  ttSize.textContent = formatSize(node.size);
  ttPctTotal.textContent = ((node.size / totalTextSize) * 100).toFixed(2) + '%';

  if (parentSize && parentSize > 0) {
    ttPctParent.textContent = ((node.size / parentSize) * 100).toFixed(1) + '%';
    ttPctParent.parentElement.style.display = 'flex';
  } else {
    ttPctParent.parentElement.style.display = 'none';
  }

  const children = Object.values(node.children || {});
  if (children.length > 0 && !node.isLeaf) {
    ttChildrenRow.style.display = 'flex';
    ttChildren.textContent = children.length + ' items';
    ttHint.textContent = 'Click to zoom in';
  } else {
    ttChildrenRow.style.display = 'none';
    ttHint.textContent = '';
  }

  if (node.isRemainder) {
    ttHint.textContent = 'Grouped items below remainder threshold';
  }

  tooltip.style.display = 'block';
  positionTooltip(e);
}

function onTooltipMove(e) {
  positionTooltip(e);
}

function onNodeLeave() {
  tooltip.style.display = 'none';
}

function positionTooltip(e) {
  let tx = e.clientX + 14;
  let ty = e.clientY + 14;
  const tw = tooltip.offsetWidth;
  const th = tooltip.offsetHeight;
  if (tx + tw > window.innerWidth - 10) tx = e.clientX - tw - 14;
  if (ty + th > window.innerHeight - 10) ty = e.clientY - th - 14;
  tooltip.style.left = tx + 'px';
  tooltip.style.top = ty + 'px';
}

// ─── Zoom / Breadcrumbs ─────────────────────────────────────────────────────

function onNodeClick(e) {
  e.stopPropagation();
  const el = e.currentTarget;
  const node = el._tmNode;
  const crateRgb = el._tmCrateRgb;

  // Find the original node by _originalId (set during cloning)
  const origId = node._originalId != null ? node._originalId : node._id;
  if (origId < 0) return; // remainder node, don't zoom

  zoomStack.push({ nodeId: origId, crateRgb, name: node.name });
  renderCurrentView();
}

function zoomToIndex(idx) {
  zoomStack = zoomStack.slice(0, idx + 1);
  renderCurrentView();
}

function zoomToRoot() {
  zoomStack = [];
  renderCurrentView();
}

function renderCurrentView() {
  const container = document.getElementById('treemap-container');
  // Use the info-bar breadcrumbs once loaded, header breadcrumbs before
  const bc = document.getElementById('breadcrumbs-bar') || document.getElementById('breadcrumbs');

  // Find the node to render
  let viewNode, crateRgb;
  if (zoomStack.length === 0) {
    viewNode = treeRoot;
    crateRgb = null;
  } else {
    const top = zoomStack[zoomStack.length - 1];
    viewNode = nodeById.get(top.nodeId);
    crateRgb = top.crateRgb;
    if (!viewNode) {
      // Fallback: reset zoom
      zoomStack = [];
      viewNode = treeRoot;
      crateRgb = null;
    }
  }

  // Clone and apply remainders
  const viewCopy = deepCloneTree(viewNode);
  applyRemainders(viewCopy, thresholdPct);

  // When zoomed into a crate/module, pass the crate color so children inherit it
  renderTreemap(viewCopy, container, crateRgb);

  // Breadcrumbs
  bc.innerHTML = '';
  const rootCrumb = document.createElement('button');
  rootCrumb.className = 'breadcrumb';
  rootCrumb.textContent = 'root';
  rootCrumb.onclick = zoomToRoot;
  bc.appendChild(rootCrumb);

  for (let i = 0; i < zoomStack.length; i++) {
    const sep = document.createElement('span');
    sep.className = 'breadcrumb-sep';
    sep.textContent = '::';
    bc.appendChild(sep);

    const crumb = document.createElement('button');
    crumb.className = 'breadcrumb';
    crumb.textContent = zoomStack[i].name;
    const idx = i;
    crumb.onclick = () => zoomToIndex(idx);
    bc.appendChild(crumb);
  }
}

// ─── Utilities ──────────────────────────────────────────────────────────────

function formatSize(bytes) {
  if (bytes >= 1048576) return (bytes / 1048576).toFixed(1) + ' MB';
  if (bytes >= 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return bytes + ' B';
}

function esc(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ─── Data loading ───────────────────────────────────────────────────────────

function loadData(jsonStr) {
  try {
    rawData = JSON.parse(jsonStr);
  } catch (e) {
    alert('Invalid JSON: ' + e.message);
    return;
  }

  if (!rawData.functions || !Array.isArray(rawData.functions)) {
    alert('Expected cargo-bloat JSON with a "functions" array.\nGenerate with: cargo bloat --release --message-format=json');
    return;
  }

  treeRoot = buildTree(rawData);
  totalTextSize = rawData['text-section-size'] || rawData['file-size'] || treeRoot.size;

  // Info bar
  document.getElementById('info-bar').style.display = 'flex';
  document.getElementById('info-file-size').textContent = 'File: ' + formatSize(rawData['file-size'] || 0);
  document.getElementById('info-text-size').textContent = 'Text section: ' + formatSize(rawData['text-section-size'] || 0);
  document.getElementById('info-functions').textContent = rawData.functions.length + ' functions';
  const crates = new Set(rawData.functions.map(f => (f.crate || '[unknown]').replace(/\?$/, '')));
  document.getElementById('info-crates').textContent = crates.size + ' crates';

  // Show treemap
  document.getElementById('drop-prompt').style.display = 'none';
  document.querySelector('header').style.display = 'none';
  document.getElementById('treemap-container').style.display = 'block';
  document.getElementById('drop-zone').classList.remove('empty');

  zoomStack = [];
  renderCurrentView();
}

// ─── Event wiring ───────────────────────────────────────────────────────────

const fileInput = document.getElementById('file-input');
fileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => loadData(ev.target.result);
  reader.readAsText(file);
  fileInput.value = ''; // allow re-selecting the same file
});

// Ensure clicking the visible button triggers the hidden file input
fileInput.previousElementSibling.addEventListener('click', (e) => {
  e.preventDefault();
  fileInput.click();
});

// Drag & drop: prevent defaults on the entire document so the browser
// doesn't navigate away, then handle the drop on the drop zone.
document.addEventListener('dragover', (e) => { e.preventDefault(); });
document.addEventListener('drop', (e) => { e.preventDefault(); });

const dropZone = document.getElementById('drop-zone');
dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.stopPropagation();
  e.dataTransfer.dropEffect = 'copy';
  dropZone.style.outline = '2px solid #537ec5';
});
dropZone.addEventListener('dragleave', (e) => {
  // Only react when actually leaving the drop zone, not entering a child
  if (!dropZone.contains(e.relatedTarget)) {
    dropZone.style.outline = '';
  }
});
dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  e.stopPropagation();
  dropZone.style.outline = '';
  const file = e.dataTransfer.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = (ev) => loadData(ev.target.result);
    reader.readAsText(file);
  }
});

document.getElementById('paste-btn').addEventListener('click', () => {
  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay';
  overlay.innerHTML = `
    <div class="modal">
      <h3>Paste cargo-bloat JSON output</h3>
      <textarea id="paste-area" placeholder='{"file-size":...,"text-section-size":...,"functions":[...]}'></textarea>
      <div class="modal-actions">
        <button class="btn" id="modal-cancel">Cancel</button>
        <button class="btn" id="modal-load" style="background:#2d6a4f">Load</button>
      </div>
    </div>`;
  document.body.appendChild(overlay);
  const area = document.getElementById('paste-area');
  area.focus();
  document.getElementById('modal-cancel').onclick = () => overlay.remove();
  document.getElementById('modal-load').onclick = () => {
    const val = area.value.trim();
    overlay.remove();
    if (val) loadData(val);
  };
  // Close on Ctrl+Enter
  area.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      const val = area.value.trim();
      overlay.remove();
      if (val) loadData(val);
    }
  });
  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
});

document.getElementById('threshold').addEventListener('input', (e) => {
  thresholdPct = parseFloat(e.target.value);
  document.getElementById('threshold-val').textContent = thresholdPct + '%';
  if (treeRoot) renderCurrentView();
});

let resizeTimer;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(() => { if (treeRoot) renderCurrentView(); }, 100);
});

// Keyboard: Escape to zoom out
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && zoomStack.length > 0) {
    zoomStack.pop();
    renderCurrentView();
  }
});

// Load from ?url= query parameter
const urlParam = new URLSearchParams(window.location.search).get('url');
if (urlParam) {
  fetch(urlParam)
    .then(r => { if (!r.ok) throw new Error(r.status + ' ' + r.statusText); return r.text(); })
    .then(text => loadData(text))
    .catch(err => alert('Failed to load ' + urlParam + ':\n' + err.message));
}
</script>
</body>
</html>
